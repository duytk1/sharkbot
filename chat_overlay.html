<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Overlay - OBS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: transparent;
            overflow: hidden;
            color: #ffffff;
            width: 100vw;
            height: 100vh;
        }

        #chat-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 15px;
            height: 100vh;
            justify-content: flex-end;
            overflow-y: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }

        #chat-container::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }

        .message {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border-left: 3px solid;
            animation: slideIn 0.3s ease-out;
            max-width: 100%;
            word-wrap: break-word;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .message.twitch {
            border-left-color: #9146ff;
        }

        .message.youtube {
            border-left-color: #ff0000;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .message.fade-out {
            animation: fadeOut 0.5s ease-out forwards;
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translateX(20px);
            }
        }

        .username {
            font-weight: 700;
            font-size: 40px;
            color: #ffffff;
            min-width: fit-content;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .message.twitch .username {
            color: #9146ff;
        }

        .message.youtube .username {
            color: #ff4444;
        }

        .message-content {
            flex: 1;
            font-size: 40px;
            line-height: 1.4;
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            word-break: break-word;
            display: inline-flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 4px;
        }

        .emote {
            display: inline-block;
            vertical-align: middle;
            height: 40px;
            width: auto;
            object-fit: contain;
        }

        .platform-badge {
            display: inline-block;
            font-size: 40px;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 5px;
            font-weight: 600;
            text-transform: uppercase;
            vertical-align: middle;
        }

        .platform-badge.twitch {
            background: #9146ff;
            color: white;
        }

        .platform-badge.youtube {
            background: #ff0000;
            color: white;
        }

        .empty-state {
            text-align: center;
            padding: 20px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
        }

        /* Smooth scrolling */
        #chat-container {
            scroll-behavior: smooth;
        }

        /* Hide messages that are too old (optional - can be configured) */
        .message.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="chat-container">
        <div class="empty-state" id="empty-state"></div>
    </div>

    <script>
        const chatContainer = document.getElementById('chat-container');
        const emptyState = document.getElementById('empty-state');
        const API_URL = '/api/chat';
        const TTS_API_URL = '/api/tts';
        const MAX_MESSAGES = 30; // Maximum messages to display
        const POLL_INTERVAL = 2000; // Poll every 2 seconds
        const TTS_POLL_INTERVAL = 1000; // Poll for TTS every 1 second
        const MESSAGE_TIMEOUT = 60000; // Hide messages after 1 minute

        let lastMessageIds = new Set();
        let messageElements = new Map();
        let lastTTSTimestamp = null;
        let audioPlayer = null;
        let sevenTVEmotes = {};
        let emoteCacheLoaded = false;

        function parseMessageWithEmotes(text) {
            if (!emoteCacheLoaded || Object.keys(sevenTVEmotes).length === 0) {
                return document.createTextNode(text);
            }

            const fragment = document.createDocumentFragment();
            
            // Sort emotes by length (longest first) to match longer emotes first
            const sortedEmotes = Object.keys(sevenTVEmotes).sort((a, b) => b.length - a.length);
            
            // Find all emote matches in the text
            const matches = [];
            sortedEmotes.forEach(emoteName => {
                // Escape special regex characters in emote name
                const escapedEmote = emoteName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // Match emote that is separated by spaces or at start/end of message
                // This handles the most common case: emotes separated by spaces in chat
                const regex = new RegExp(`(^|\\s)${escapedEmote}(?=\\s|$)`, 'gi');
                let match;
                while ((match = regex.exec(text)) !== null) {
                    // Adjust index if match includes leading whitespace
                    const leadingSpace = match[1] || '';
                    const actualIndex = match.index + leadingSpace.length;
                    matches.push({
                        emote: emoteName,
                        index: actualIndex,
                        length: emoteName.length
                    });
                }
            });
            
            // Sort matches by index
            matches.sort((a, b) => a.index - b.index);
            
            // Remove overlapping matches (keep first match)
            const nonOverlappingMatches = [];
            let lastEnd = 0;
            matches.forEach(match => {
                if (match.index >= lastEnd) {
                    nonOverlappingMatches.push(match);
                    lastEnd = match.index + match.length;
                }
            });
            
            // Build the fragment with text and emotes
            let lastIndex = 0;
            nonOverlappingMatches.forEach(match => {
                // Add text before the emote
                if (match.index > lastIndex) {
                    fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                }
                
                // Add the emote image
                const img = document.createElement('img');
                img.src = sevenTVEmotes[match.emote];
                img.className = 'emote';
                img.alt = match.emote;
                img.title = match.emote;
                fragment.appendChild(img);
                
                lastIndex = match.index + match.length;
            });
            
            // Add remaining text
            if (lastIndex < text.length) {
                fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
            }
            
            // If no matches, return plain text
            if (nonOverlappingMatches.length === 0) {
                return document.createTextNode(text);
            }
            
            return fragment;
        }

        function createMessageElement(messageData) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${messageData.platform}`;
            messageDiv.dataset.messageId = `${messageData.user}_${messageData.timestamp}_${Date.now()}`;
            messageDiv.dataset.timestamp = messageData.timestamp || Date.now();

            const usernameSpan = document.createElement('span');
            usernameSpan.className = 'username';
            usernameSpan.textContent = messageData.user + ':';

            const contentSpan = document.createElement('span');
            contentSpan.className = 'message-content';
            
            // Parse message with emotes (only for Twitch)
            if (messageData.platform === 'twitch') {
                const parsedContent = parseMessageWithEmotes(messageData.message);
                contentSpan.appendChild(parsedContent);
                // Debug: log if emotes were found
                if (emoteCacheLoaded && Object.keys(sevenTVEmotes).length > 0) {
                    const messageText = messageData.message.toLowerCase();
                    const foundEmotes = Object.keys(sevenTVEmotes).filter(emote => 
                        messageText.includes(emote.toLowerCase())
                    );
                    if (foundEmotes.length > 0) {
                        console.log('Message contains potential emotes:', foundEmotes, 'in message:', messageData.message);
                    }
                }
            } else {
                contentSpan.textContent = messageData.message;
            }

            messageDiv.appendChild(usernameSpan);
            messageDiv.appendChild(contentSpan);

            return messageDiv;
        }

        function addMessage(messageData) {
            const messageId = `${messageData.user}_${messageData.timestamp || Date.now()}`;
            
            // Skip if we've already shown this message
            if (lastMessageIds.has(messageId)) {
                return;
            }

            lastMessageIds.add(messageId);
            
            // Hide empty state
            if (emptyState) {
                emptyState.style.display = 'none';
            }

            const messageElement = createMessageElement(messageData);
            chatContainer.appendChild(messageElement);
            messageElements.set(messageId, messageElement);

            // Remove oldest messages if we exceed MAX_MESSAGES
            while (chatContainer.children.length > MAX_MESSAGES + 1) { // +1 for empty state
                const oldestChild = chatContainer.children[0];
                if (oldestChild !== emptyState) {
                    const oldestId = oldestChild.dataset.messageId;
                    if (oldestId) {
                        lastMessageIds.delete(oldestId.split('_')[0] + '_' + oldestChild.dataset.timestamp);
                        messageElements.delete(oldestId);
                    }
                    chatContainer.removeChild(oldestChild);
                }
            }

            // Auto-scroll to bottom
            chatContainer.scrollTop = chatContainer.scrollHeight;

            // Set timeout to fade out old messages
            setTimeout(() => {
                if (messageElement.parentNode) {
                    messageElement.classList.add('fade-out');
                    setTimeout(() => {
                        if (messageElement.parentNode) {
                            messageElement.remove();
                            messageElements.delete(messageId);
                        }
                    }, 500);
                }
            }, MESSAGE_TIMEOUT);
        }

        function updateChat() {
            fetch(API_URL)
                .then(response => response.json())
                .then(data => {
                    if (data.messages && Array.isArray(data.messages)) {
                        // Add new messages
                        data.messages.forEach(message => {
                            addMessage(message);
                        });

                        // Show empty state if no messages
                        if (data.messages.length === 0 && chatContainer.children.length === 1) {
                            if (emptyState) {
                                emptyState.style.display = 'block';
                            }
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching chat messages:', error);
                });
        }

        function load7TVEmotes() {
            fetch('/api/7tv/emotes')
                .then(response => response.json())
                .then(data => {
                    if (data.emotes) {
                        sevenTVEmotes = data.emotes;
                        emoteCacheLoaded = true;
                        const emoteCount = Object.keys(sevenTVEmotes).length;
                        console.log(`Loaded ${emoteCount} 7TV emotes`);
                        if (emoteCount === 0) {
                            console.warn('No 7TV emotes loaded. Check server logs for errors.');
                        } else {
                            // Log first few emote names for debugging
                            const sampleEmotes = Object.keys(sevenTVEmotes).slice(0, 5);
                            console.log('Sample emotes:', sampleEmotes);
                        }
                    } else if (data.error) {
                        console.error('7TV API error:', data.error);
                        // Retry after 30 seconds
                        setTimeout(load7TVEmotes, 30000);
                    }
                })
                .catch(error => {
                    console.error('Error loading 7TV emotes:', error);
                    // Retry after 30 seconds
                    setTimeout(load7TVEmotes, 30000);
                });
        }

        function initializeTTSTimestamp() {
            // On overlay load, check if TTS file exists and set initial timestamp
            // This prevents playing old TTS files when the overlay refreshes
            fetch(TTS_API_URL)
                .then(response => response.json())
                .then(data => {
                    if (data.exists && data.timestamp && data.size > 0) {
                        // Set the initial timestamp so we don't play this old file
                        lastTTSTimestamp = data.timestamp;
                        console.log('Initialized TTS timestamp (ignoring old file):', data.timestamp);
                    }
                })
                .catch(error => {
                    // Silently fail - TTS might not be available
                    console.debug('TTS initialization check error (this is normal if no TTS file exists):', error);
                });
        }

        function checkForTTS() {
            fetch(TTS_API_URL)
                .then(response => response.json())
                .then(data => {
                    if (data.exists && data.timestamp && data.size > 0) {
                        // Check if this is a new TTS file (use timestamp to detect new files)
                        // Only play if timestamp is significantly different (at least 0.1 seconds)
                        if (lastTTSTimestamp === null || Math.abs(data.timestamp - lastTTSTimestamp) > 0.1) {
                            // Don't interrupt if audio is currently playing
                            if (audioPlayer && !audioPlayer.paused && !audioPlayer.ended) {
                                return;
                            }
                            
                            lastTTSTimestamp = data.timestamp;
                            
                            // Stop any currently playing audio
                            if (audioPlayer) {
                                audioPlayer.pause();
                                audioPlayer.currentTime = 0;
                                audioPlayer = null;
                            }
                            
                            // Create new audio element and play
                            audioPlayer = new Audio(data.url + '?t=' + data.timestamp);
                            audioPlayer.volume = 1.0; // Full volume
                            
                            // Preload the audio to ensure it's ready
                            audioPlayer.preload = 'auto';
                            
                            audioPlayer.play().catch(error => {
                                console.error('Error playing TTS:', error);
                                // Some browsers require user interaction before playing audio
                                // This is expected in OBS browser source
                            });
                            
                            // Clean up after playback
                            audioPlayer.addEventListener('ended', () => {
                                audioPlayer = null;
                            });
                            
                            audioPlayer.addEventListener('error', (error) => {
                                console.error('TTS playback error:', error);
                                audioPlayer = null;
                            });
                        }
                    }
                })
                .catch(error => {
                    // Silently fail - TTS might not be available
                    console.debug('TTS check error (this is normal if no TTS file exists):', error);
                });
        }

        // Initial load
        initializeTTSTimestamp(); // Initialize TTS timestamp first to ignore old files
        load7TVEmotes(); // Load 7TV emotes first
        updateChat();
        // Don't check for TTS immediately - wait a bit to avoid playing old files
        setTimeout(checkForTTS, 1000);
        
        // Reload emotes every 5 minutes (in case new ones are added)
        setInterval(load7TVEmotes, 300000);

        // Poll for new messages
        setInterval(updateChat, POLL_INTERVAL);

        // Poll for new TTS files
        setInterval(checkForTTS, TTS_POLL_INTERVAL);

        // Clean up old message IDs periodically to prevent memory issues
        setInterval(() => {
            if (lastMessageIds.size > MAX_MESSAGES * 2) {
                const idsArray = Array.from(lastMessageIds);
                lastMessageIds = new Set(idsArray.slice(-MAX_MESSAGES));
            }
        }, 60000); // Every minute
    </script>
</body>
</html>

